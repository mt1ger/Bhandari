#include <iostream>
#include <vector>
#include <climits>
#include "Bhandari.h"

using namespace std;

void Bhandari::update_topology (int src, int dest) {
	UpdatedTopology = network->NodesWeight;

	for (int i = 1; i < network->DRoutingTable[src][dest].size (); i++) {
		UpdatedTopology[network->DRoutingTable[src][dest][i - 1]][network->DRoutingTable[src][dest][i]] = INT_MAX;
		UpdatedTopology[network->DRoutingTable[src][dest][i]][network->DRoutingTable[src][dest][i - 1]] = UpdatedTopology[network->DRoutingTable[src][dest][i]][network->DRoutingTable[src][dest][i - 1]] * -1;
	}

	// cout << endl << "B Updated Table: " << endl;
	// for (int i = 0; i < network->DRoutingTable[src][dest].size (); i++) {
	// 	cout << network->DRoutingTable[src][dest][i] << ' ';
	// }
	// cout << endl;
	// for (int i = 0; i < network->NumofNodes; i++) {
	// 	for (int j = 0; j < network->NumofNodes; j++) {
	// 		cout << UpdatedTopology[i][j] << ' ';
	// 	}
	// 	cout << endl;
	// }
	// for (int i = 0; i < network->NumofNodes; i++) {
	// 	for (int j = 0; j < network->NumofNodes; j++) {
	// 		cout << network->NodesWeight[i][j] << ' ';
	// 	}
	// 	cout << endl;
	// }
}

vector<int> Bhandari::sp_with_negative_weight (int src, int dest) {
	vector<int> ShortestPath;
	Dijkstra dijkstra (network);
	RoutingTable routingTable (network);

	dijkstra.ajacent_nodes (dijkstra.AjacentNodes, UpdatedTopology);
	
	for (int i = 0; i < network->NumofNodes; i++) {
		dijkstra.shortest_path (i, -1, hpredecessors);

		predecessors.push_back (hpredecessors);
		hpredecessors.clear ();
	}	

	return ShortestPath;
}
